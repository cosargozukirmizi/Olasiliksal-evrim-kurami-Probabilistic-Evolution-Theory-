/*

Copyright (C) 2015  Cosar Gozukirmizi

    
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/* ********************************* */
/* Bu betik, sag yani ikinci derece  */
/* cokcokterimli olan bir 2 bilinme- */
/* yenli dizgenin olasiliksal evrim  */
/* yaklasimi ve degismezlik eklenim- */ 
/* li uzay genisletimi ile cozumu i- */ 
/* cin atilan adimlari icermektedir. */
/* bita ve ksi eniyileyimi eklenmis- */
/* tir. Ksi, DEUG baglaminda eklem-  */
/* lenen sayildir.                   */
/* Son guncelleyim: 25 Aralik 2014   */
/* ********************************* */

DIGITS:=40:

/* ********************************* */
/* Goreturev isleclerinin tanimi     */
/* ********************************* */

D1 := (y) -> diff(y,x1):
D2 := (y) -> diff(y,x2):

/* ********************************* */
/* Sag yan islevlerinin belirtimi    */
/* ********************************* */

r1:= (x1,x2)-> x1+x2+x1*x2:
r2:= (x1,x2)-> x1-x2^2+1:

Mat := Dom::Matrix():

/* ********************************* */
/* Yonelegim yoneyinin tanimi        */
/* ********************************* */

GradYoneyi := () -> Mat([[args()]]):

/* ********************************* */
/* Sag yan isleverini iceren yoney   */
/* ********************************* */

R := ()-> Mat([r1(args()),r2(args())]):

/* ********************************* */
/* Islec yoneyinin iccarpim ile yo-  */
/* neye etki ettirimi		     */
/* ********************************* */

uygula := proc(u_gy, u_f)
begin
 u_retvec:=Mat(nops(u_gy),1):
  for u_i from 1 to nops(u_gy) do
   u_retvec[u_i]:=u_gy[u_i](u_f)
  end_for:
 return(u_retvec):
end_proc:

/* ********************************* */
/* Islec yoneyinin Kronecker uslusu- */
/* nun belirlenimi 		     */
/* ********************************* */

kroneckerPowerOp := proc(krpo_u,krpo_j)
begin
 if krpo_j = 0 then 
  print("kroneckerPowerOp not defined for 0"):
 end_if:
 krpo_ret_vec:=krpo_u:
 if krpo_j = 1 then 
  return( krpo_ret_vec ):
 end_if:
  
 for krpo_it1 from 2 to krpo_j do
  krpo_ret_vec2:=Mat(nops(krpo_ret_vec)
               *nops(krpo_u),1):
  krpo_ind:=1:  
  for krpo_it2 from 1 to nops(krpo_ret_vec) do 
   for krpo_it3 from 1 to nops(krpo_u) do
    krpo_ret_vec2[krpo_ind]:=krpo_ret_vec[krpo_it2] \
                            @ krpo_u[krpo_it3]:
    krpo_ind:=krpo_ind+1:
   end_for:    
  end_for:
  krpo_ret_vec:=krpo_ret_vec2:  
 end_for:
return(krpo_ret_vec2)
end_proc:


/* ********************************* */
/* Yoney Kronecker uslusunun belir-  */
/* lenimi			     */
/* ********************************* */

kroneckerPower := proc(krp_u,krp_j)
begin
 if krp_j < 0 then
  return(Mat([0])):
 elif krp_j = 0 then
  return(Mat([1])):
 end_if: 
 krp_retvec := krp_u:
 for krp_i from 2 to krp_j do 
  krp_retvec:=linalg::kroneckerProduct(krp_retvec
             , krp_u)
 end_for:
return(krp_retvec): 
end_proc:

/* ********************************* */
/* Kronecker uslu toplamdizi katsayi */
/* belirlenimi (bir islev icin)	     */
/* ********************************* */

F_bul := proc(rx, F_bul_it1)
begin
 if F_bul_it1 = 0 then
  return(evalAt(rx, (x1=0,x2=0))):
 end_if:
 tmp_F_bul:=(1/(F_bul_it1!) \
           * uygula(kroneckerPowerOp(GradYoneyi(D1,D2)
           , F_bul_it1), rx)): 
 return(evalAt(tmp_F_bul,(x1=0, x2=0))):
end_proc:


/* ********************************* */
/* Butun dizey katsayilarin belirle- */
/* nimi				     */
/* ********************************* */

F_asil(0):=Mat(nops(R(x1,x2)),1):
for iter_Fa_all from 1 to nops(R(x1,x2)) do 
 F_asil(0)[iter_Fa_all]:=evalAt(R(x1,x2)[iter_Fa_all], (x1=0,x2=0) ):
end_for:
for iter_F_ind from 1 to 2 do 
 F_asil(iter_F_ind):=Mat(nops(R(x1,x2))^iter_F_ind
                   , nops(R(x1,x2))):
 for iter_F_all from 1 to nops(R(x1,x2)) do 
  F_asil(iter_F_ind):=linalg::setCol(F_asil(iter_F_ind)
                     , iter_F_all, F_bul(R(x1,x2)[iter_F_all]
                     , iter_F_ind)): 
 end_for:
end_for:

F_asil(1):=linalg::transpose(F_asil(1)):
F_asil(2):=linalg::transpose(F_asil(2)):

/* ********************************* */
/* DEUG ile genisletilmis dizey kat- */
/* sayilara gecis		     */
/* ********************************* */

F_asil_aug(1):=Mat::concatMatrix(F_asil(1), 1/ksi*F_asil(0)):
F_asil_aug(1):=Mat::stackMatrix(F_asil_aug(1)
              , Mat(1,Mat::matdim(F_asil(1))[2]+1)):


/* ********************************* */
/* En bastaki denklem sayisi tanimi  */
/* ********************************* */

n:=Mat::matdim(F_asil(1))[1]:

/* ********************************* */
/* Esneklikli genisletilmis birinci  */ 
/* katsayi dizeyinin belirtimi       */
/* ********************************* */

F_asil_faug(1):=bita*Mat::identity(n):

/* ********************************* */
/* Yerdegistirim dizeyi tanimi       */
/* ********************************* */

permat:=proc(pm_n)
begin
pm_retmat:=Mat(1,pm_n^2+2*pm_n+1):
pm_retmat[1,1]:=1:
 for pm_i from 2 to (pm_n+1)^2 do 
  pm_temp := Mat(pm_n^2+2*pm_n+1,1):
  if (pm_i mod pm_n+1)=0 and pm_i<(pm_n^2+pm_n) then
   pm_temp[pm_n^2+pm_i/(pm_n+1),1]:=1:
  elif (pm_i<pm_n^2+pm_n) then
   pm_temp[pm_i-floor(pm_i/(pm_n+1)),1]:=1:
  else
   pm_temp[pm_i,1]:=1:
  end_if:
  pm_retmat:=Mat::stackMatrix(pm_retmat
            , linalg::transpose(pm_temp)): 
 end_for:
end_proc:

/* ********************************* */
/* Ikinci katsayi dizeyinin bulunumu */
/* ********************************* */

G12(2):=1/(2*ksi)*F_asil(1)-1/(7*n+8)*1/(2*ksi)\
       *linalg::tr(F_asil(1))*Mat::identity(n):
G22(2):=Mat(1,n):
F_asil_faug(2):=Mat::concatMatrix(F_asil(2),G12(2)):
F_asil_faug(2):=Mat::concatMatrix(F_asil_faug(2)
               ,1/ksi*F_asil(1)-bita/ksi*Mat::identity(n)-G12(2)):
F_asil_faug(2):=Mat::concatMatrix(F_asil_faug(2)
               ,1/(ksi^2)*F_asil(0)):
F_asil2_alt:=Mat::concatMatrix(Mat(1,n^2+2*n),[-bita/ksi]):
F_asil_faug(2):=Mat::stackMatrix(F_asil_faug(2),F_asil2_alt):
F_asil_faug(2):=F_asil_faug(2)
              *(permat(Mat::matdim(F_asil(1))[1]))^(-1):

/* ********************************* */
/* bita belirleyim  		     */ 
/* ********************************* */

bita := 2/(7*nops(R(x1,x2))+8)*linalg::tr(F_asil(1)):

/* ********************************* */
/* bita'nin sifirlanimi celiski ure- */
/* tebilecek bir olgudur. Dolayisiy- */
/* sifirlanima karsi onlem alimi ge- */
/* reklidir.	  		     */ 
/* ********************************* */

if bita = 0 then
 bita := bita + 0.00001:
end_if:

/* ********************************* */
/* Irakgorurun bolumlerini betimle-  */
/* yen dizeylerin tanimi             */
/* ********************************* */

M := proc(M_j)
begin
 M_rv:=0:
 M_I_n := Mat::identity(n+1):
 for M_k from 0 to M_j-1 do    
  M_rv:=M_rv+linalg::kroneckerProduct(linalg::kroneckerProduct(
        kroneckerPower(M_I_n,
        M_k),F_asil_faug(2)), kroneckerPower(M_I_n, M_j-1-M_k)):
 end_for:
 return(M_rv):
end_proc:

/* ********************************* */
/* Irakgorur dizeylerinin tanimi     */
/* ********************************* */

T := proc(T_k)
begin
 T_ret:=1:
 for T_l from 1 to T_k do 
  T_ret:=T_ret*M(T_l):
 end_for: 
return(T_ret):
end_proc:


/* ********************************* */
/* Dordullestirilim isleci tanimi    */
/* ********************************* */

squarificate := proc(sq_F, sq_a)
begin
 sq_res:=0:
 sq_i:=1:
// print(sq_F):
 for sq_i from 1 to n+1 do
  sq_res:=sq_res+sq_a[sq_i,1]
  *linalg::submatrix(sq_F,1..n+1,((n+1)*(sq_i-1)+1)..((n+1)*(sq_i-1)+1+n)):
 end_for:
 return(sq_res):
end_proc:

/* ********************************* */
/* Dordullestirilmis dizeyleri       */
/* ureten yapi 			     */
/* ********************************* */

S := proc(S_i,S_a,S_F)
option remember;
begin
 if S_i = 0 then 
   S_ret := Mat::identity(n+1):
 elif S_i = 1 then
  S_ret := (squarificate(S_F,S_a)): 
 elif S_i = 2 then
  S_ret := (S(1, S_a, S_F)^2
         +squarificate(S_F, S(1, S_a, S_F)*S_a)):
 elif S_i = 3 then
//  S_ret := 3*S(1, S_a, S_F)*S(2, S_a, S_F)
//         -2*S(1, S_a, S_F)+squarificate(S_F, S(2, S_a, S_F)*S_a):
 S_ret := squarificate(S_F,squarificate(S_F,squarificate(S_F,S_a)*S_a)*S_a)
        +squarificate(S_F,S_a)*squarificate(S_F,squarificate(S_F,S_a)*S_a)
        +squarificate(S_F,S_a)^3
        +squarificate(S_F,squarificate(S_F,S_a)^2*S_a)
        +2*squarificate(S_F,squarificate(S_F,S_a)*S_a)*squarificate(S_F,S_a):
 else
  print("oops"):
  S_ret :=0 :
 end_if:
 return(S_ret):
end_proc:


/* ********************************* */
/* Dizgenin cozumunu  		     */
/* ureten asil yapi 		     */
/* ********************************* */

hhc := proc(hhc_k)
begin
 hhc_rv:=0:
 hhc_a_aug:=linalg::stackMatrix(Mat([a1,a2]),[ksi]):
 hhc_summand:=0:
 hhc_ret:=0:
 for hhc_j from 0 to hhc_k do 
//  hhc_summand:=1/(hhc_j!)\
//  *(((1-exp(bita*t))/(-bita))^hhc_j)*T(hhc_j)
//  *kroneckerPower(hhc_a_aug, hhc_j+1):
    hhc_summand:=1/(hhc_j!)\
    *(((1-exp(bita*t))/(-bita))^hhc_j)*S(hhc_j,hhc_a_aug, F_asil_faug(2))
    *hhc_a_aug:
  hhc_ret:=hhc_ret+hhc_summand:
 end_for: 
 return(exp(bita*t)*hhc_ret):
end_proc:

/* ********************************* */
/* Asil yapiya yapilan cagri. Prose- */
/* durun degistirgeni, kesme kerte-  */
/* sidir.			     */
/* ********************************* */

cozum:=hhc(3):

/* ********************************* */
/* DEUG baglaminda eklemlenen sayi-  */
/* lin eniyileyimi icin amac isle-   */
/* vimsisinin belirtimi.             */
/* ********************************* */

J:=((norm(F_asil(2),Frobenius)^2+1/2*(1/bk)\
*norm(F_asil(1),Frobenius)^2-(23*n+24)/((7*n+8)^2)\
*1/2*(1/bk)*linalg::tr(F_asil(1))^2+((1/bk)^2)
*norm(F_asil(0),Frobenius)^2))\
*(norm(Mat([a1,a2]),Frobenius)^2+bk):

Jdiff:=diff(J,bk):

/* ********************************* */
/* Baslangic kosullari burada be-    */
/* lirtilebilir, ya da simgecil du-  */
/* zeyde birakilabilir.	 	     */
/* ********************************* */

a1:=.1:
a2:=.2:

/* ********************************* */
/* Amac islevimsisinden gelen eniyi- */
/* lenmis degerlerin dordul islev    */
/* koku belirlenimi ile bulunmasi    */
/* ********************************* */

tmpkok:=(numeric::realroots(Jdiff,bk=0..100)[2]):

/* ********************************* */
/* Eniyilenmis degerin atanimi. Sim- */
/* gecil duzeyde tutmak icin bu ata- */
/* mayi yapmamak yeterlidir.         */
/* ********************************* */

//ksi:=sqrt((tmpkok[1]+tmpkok[2])/2):

/* ********************************* */
/* Belirli t degerleri icin cozumun  */
/* ekrana yazimi                     */
/* ********************************* */

//DIGITS:=4:
//Pref::trailingZeroes(TRUE):

//plotdataF:=[ ]:
//plotdataS:=[ ]:

for it_i from 0 to 1 step 0.1 do 
 print(NoNL,expr2text(it_i)."\t".expr2text(evalAt(cozum[1,1]
  ,[t=it_i]))."\t".expr2text(
  evalAt(cozum[2,1],[t=it_i]))."\n"):  
// plotdataF := plotdataF . [[it_i, evalAt(cozum[1,1],[t=it_i]) ]]: 
// plotdataS := plotdataS . [[it_i, evalAt(cozum[2,1],[t=it_i])]]: 
end_for:

/* ********************************* */
/* Baslangic deger sorununun cizim   */
/* amacli yeniden belirtimi          */
/* ********************************* */

//f := (t, Y) -> [Y[1]+Y[2]+Y[1]*Y[2],Y[1]-Y[2]^2+1]:
//t0 := 0: Y0 := [a1, a2]:

/* ********************************* */
/* Ayriklastirim tabanli yontem ile  */
/* cozum ve cizim                    */
/* ********************************* */

//p1 := plot::Ode2d(f,[i/10 $ i = 0..10], Y0
//                ,PointSize = 1.5*unit::mm
//                , LineWidth = 0.2*unit::mm
//                , GridVisible = TRUE
//                ):

//p2 := plot::Function2d(cozum[1,1]
//, t=0..1, LineWidth = 0.2*unit::mm
//, LegendText="x1 by PEA"):
//p2::LineColor := RGB::VioletRedPale:
//p2d := plot::PointList2d(plotdataF
//,PointColor = RGB::VioletRedPale
//, PointStyle = Diamonds,PointSize = 3*unit::mm):

//p3 := plot::Function2d(cozum[2,1], t=0..1
//, LineWidth = 0.2*unit::mm
//, LegendText="x2 by PEA"):
//p3::LineColor := RGB::ManganeseBlue:
//p3d := plot::PointList2d(plotdataS, PointStyle = Diamonds
//,PointColor = RGB::ManganeseBlue,PointSize = 3*unit::mm):

//plot(p1, p2, p2d, p3, p3d
//    , OutputFile = "mypicture.jpg", LegendVisible=TRUE):

quit:

/* ********************************* */
/* Betik sonu		             */
/* ********************************* */

